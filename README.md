# Claims Management System

A comprehensive Django-based claims management system with modern UI, real-time interactions, and advanced analytics capabilities.

## üöÄ Features

### Core Functionality
- **Claims List View**: Display all claims with ID, patient name, billed amount, paid amount, status, and insurer name
- **HTMX Detail View**: Show claim-specific information (CPT codes, denial reasons, notes) without full page reload
- **Flag & Annotate**: Allow users to flag claims for review and add custom notes stored in database
- **Search & Filter**: Implement search functionality for claim status or insurer name
- **Admin Dashboard**: Stats like total flagged claims, average underpayment
- **CSV Re-upload**: Support for data overwrite or append logic
- **User Authentication**: Simple login system with user-specific annotations

### Advanced Features
- **Real-time Updates**: HTMX-powered dynamic content updates
- **Analytics Dashboard**: Charts and statistics for claims analysis
- **Export Functionality**: CSV export for individual claims
- **Responsive Design**: Mobile-friendly Bootstrap 5 interface
- **Role-based Access**: User-specific permissions and data access

## üöÄ Deployment to Render

### Quick Deploy to Render

This Django Claims Management System is optimized for deployment on Render. Follow these steps to deploy your application:

#### 1. Prepare Your Repository

Ensure your repository contains these files:
- `render.yaml` - Render configuration
- `requirements.txt` - Python dependencies
- `build.sh` - Build script
- `claims_interface/settings.py` - Updated for production

#### 2. Deploy to Render

**Option A: Using Render Dashboard (Recommended)**

1. **Sign up/Login to Render**
   - Go to [render.com](https://render.com)
   - Create account or login

2. **Create New Web Service**
   - Click "New +" ‚Üí "Web Service"
   - Connect your GitHub repository
   - Select your repository

3. **Configure Service**
   - **Name**: `claims-management-system`
   - **Environment**: `Python 3`
   - **Build Command**: `./build.sh`
   - **Start Command**: `gunicorn claims_interface.wsgi:application`

4. **Environment Variables**
   Add these in the Render dashboard:
   ```
   SECRET_KEY=your-secret-key-here
   DEBUG=False
   ALLOWED_HOSTS=.onrender.com
   ```

5. **Deploy**
   - Click "Create Web Service"
   - Wait for build to complete (2-3 minutes)

**Option B: Using render.yaml (Blue-Green Deploy)**

1. **Push to GitHub**
   ```bash
   git add .
   git commit -m "Add Render deployment configuration"
   git push origin main
   ```

2. **Connect Repository**
   - Go to Render Dashboard
   - Click "New +" ‚Üí "Blueprint"
   - Connect your repository
   - Render will automatically detect `render.yaml`

3. **Deploy**
   - Click "Create Blueprint Instance"
   - Render will create the service automatically

#### 3. Post-Deployment Setup

After successful deployment:

1. **Create Superuser**
   ```bash
   # Access your Render service shell
   # Go to your service ‚Üí Shell
   python manage.py createsuperuser
   ```

2. **Load Sample Data**
   ```bash
   # In Render shell
   python manage.py load_claims_data
   ```

3. **Verify Deployment**
   - Visit your Render URL
   - Test login functionality
   - Check all features work correctly

### Render Configuration Files

#### `render.yaml`
```yaml
services:
  - type: web
    name: claims-management-system
    env: python
    plan: free
    buildCommand: pip install -r requirements.txt
    startCommand: gunicorn claims_interface.wsgi:application
    envVars:
      - key: PYTHON_VERSION
        value: 3.9.16
      - key: DJANGO_SETTINGS_MODULE
        value: claims_interface.settings
      - key: SECRET_KEY
        generateValue: true
      - key: DEBUG
        value: False
      - key: ALLOWED_HOSTS
        value: .onrender.com
    healthCheckPath: /
    autoDeploy: true
```

#### `build.sh`
```bash
#!/usr/bin/env bash
# exit on error
set -o errexit

pip install -r requirements.txt
python manage.py collectstatic --no-input
python manage.py migrate
```

#### Updated `requirements.txt`
```
Django==4.2.7
pandas==2.1.3
python-dotenv==1.0.0
django-crispy-forms==2.1
crispy-bootstrap5==0.7
gunicorn==21.2.0
whitenoise==6.6.0
```

### Environment Variables

#### Required Variables
- `SECRET_KEY`: Django secret key (auto-generated by Render)
- `DEBUG`: Set to `False` for production
- `ALLOWED_HOSTS`: Set to `.onrender.com` for Render domains

#### Optional Variables
- `DATABASE_URL`: For external database (if using PostgreSQL)
- `STATIC_URL`: Static files URL (default: `/static/`)

### Production Settings

The application is configured for production with:

1. **Security Settings**
   - `DEBUG = False`
   - CSRF protection enabled
   - Secure headers configured
   - SQL injection protection

2. **Static Files**
   - WhiteNoise for static file serving
   - Compressed and cached static files
   - Automatic static file collection

3. **Database**
   - SQLite for free tier (persistent)
   - PostgreSQL support available
   - Automatic migrations

4. **Performance**
   - Gunicorn WSGI server
   - Optimized static file serving
   - Database query optimization

### Troubleshooting Render Deployment

#### Common Issues

**1. Build Failures**
```bash
# Check build logs in Render dashboard
# Common causes:
# - Missing requirements.txt
# - Python version mismatch
# - Import errors
```

**2. Static Files Not Loading**
```bash
# Ensure build.sh includes:
python manage.py collectstatic --no-input

# Check STATIC_ROOT in settings.py
STATIC_ROOT = BASE_DIR / 'staticfiles'
```

**3. Database Issues**
```bash
# Ensure migrations run:
python manage.py migrate

# Check database permissions
# Verify database connection
```

**4. 500 Errors**
```bash
# Check Render logs
# Common causes:
# - Missing SECRET_KEY
# - Database connection issues
# - Import errors in views
```

#### Debug Commands

**Access Render Shell**
1. Go to your service in Render dashboard
2. Click "Shell" tab
3. Run debug commands:

```bash
# Check Django setup
python manage.py check

# Test database
python manage.py shell
>>> from claims.models import ClaimList
>>> ClaimList.objects.count()

# Check static files
python manage.py collectstatic --dry-run

# Test server locally
python manage.py runserver 0.0.0.0:8000
```

### Scaling on Render

#### Free Tier Limitations
- 750 hours/month
- 512MB RAM
- Shared CPU
- Sleep after 15 minutes of inactivity

#### Paid Plans
- **Starter**: $7/month - Always on, 512MB RAM
- **Standard**: $25/month - 1GB RAM, dedicated CPU
- **Pro**: $50/month - 2GB RAM, dedicated CPU

#### Upgrade Considerations
1. **Database**: Switch to PostgreSQL for better performance
2. **Static Files**: Use CDN for global distribution
3. **Caching**: Implement Redis for session storage
4. **Monitoring**: Add application monitoring

### Custom Domain Setup

1. **Add Custom Domain**
   - Go to your service in Render
   - Click "Settings" ‚Üí "Custom Domains"
   - Add your domain

2. **Update DNS**
   - Point your domain to Render's servers
   - Add CNAME record

3. **SSL Certificate**
   - Render provides automatic SSL
   - Certificates auto-renew

### Monitoring and Logs

#### Access Logs
1. Go to your service in Render
2. Click "Logs" tab
3. View real-time logs

#### Health Checks
- Render automatically checks `/` endpoint
- Configure custom health check path
- Monitor response times

#### Performance Monitoring
- Track request/response times
- Monitor memory usage
- Check database performance

### Backup and Recovery

#### Database Backup
```bash
# In Render shell
python manage.py dumpdata > backup.json

# Download backup
# Upload to secure storage
```

#### Code Backup
- Use Git for version control
- Regular commits to GitHub
- Tag releases for rollback

### Security Best Practices

1. **Environment Variables**
   - Never commit secrets to Git
   - Use Render's environment variables
   - Rotate secrets regularly

2. **Dependencies**
   - Keep dependencies updated
   - Monitor security advisories
   - Use virtual environments

3. **Access Control**
   - Use strong passwords
   - Implement rate limiting
   - Monitor access logs

### Cost Optimization

#### Free Tier Tips
- Use sleep mode for development
- Optimize static files
- Minimize database queries
- Use efficient caching

#### Paid Tier Optimization
- Right-size your service
- Use appropriate database plans
- Monitor resource usage
- Implement caching strategies

---

**Next Steps:**
1. Deploy to Render using the guide above
2. Set up your custom domain (optional)
3. Configure monitoring and alerts
4. Set up regular backups
5. Monitor performance and optimize

For additional help, check the [Render Documentation](https://render.com/docs) or contact Render support.

## üìã Requirements

- Python 3.8+
- Django 4.2.7
- SQLite (default) or PostgreSQL
- Modern web browser with JavaScript enabled

## üõ†Ô∏è Installation

### 1. Clone the Repository
```bash
git clone <repository-url>
cd project
```

### 2. Install Dependencies
```bash
pip install -r requirements.txt
```

### 3. Database Setup
```bash
python manage.py makemigrations
python manage.py migrate
```

### 4. Create Superuser (Optional)
```bash
python manage.py createsuperuser
```

### 5. Load Sample Data
```bash
python manage.py load_claims_data
```

## üìä Data Ingestion

### Initial Data Loading
The system provides two management commands for data ingestion:

#### 1. Load Claims Data (from existing database)
```bash
python manage.py load_claims_data
```
This command loads data from an existing SQLite database into Django models.

#### 2. Reload Claims Data (from CSV files)
```bash
# Overwrite existing data
python manage.py reload_claims_data --mode overwrite

# Append to existing data
python manage.py reload_claims_data --mode append

# Use custom file paths
python manage.py reload_claims_data --mode overwrite --claim-list path/to/claims.csv --claim-detail path/to/details.csv
```

### CSV File Format
The system expects CSV files with the following structure:

**Claim List CSV (`claim_list_data.csv`):**
```csv
id|patient_name|billed_amount|paid_amount|status|insurer_name|discharge_date
1001|John Doe|5000.00|4500.00|Paid|Blue Cross|2024-01-15
1002|Jane Smith|3000.00|0.00|Denied|Aetna|2024-01-20
```

**Claim Detail CSV (`claim_detail_data.csv`):**
```csv
id|claim_id|denial_reason|cpt_codes
1|1001||99213;99214
2|1002|Insufficient documentation|99215
```

### Data Sources
- **Default Location**: `Data/` directory
- **Supported Formats**: CSV (pipe-delimited), JSON
- **Database**: SQLite (default), supports PostgreSQL

## üîß Script Execution & Usage

### Management Commands Overview
The system provides two main management commands for data ingestion, each with multiple execution options:

#### 1. Load Claims Data Command (`load_claims_data`)
**Purpose**: Migrate data from existing SQLite database to Django models

**Basic Execution**:
```bash
python manage.py load_claims_data
```

**What it does**:
- Connects to existing SQLite database (`claims.db`)
- Extracts all data from `claim_list` and `claim_detail` tables
- Converts data types (strings to dates, amounts to decimals)
- Uses `bulk_create` for optimal performance
- Handles data validation and error logging
- Clears existing Django model data before loading

**Execution Options**:
```bash
# Standard execution
python manage.py load_claims_data

# With verbose output
python manage.py load_claims_data --verbosity=2

# With error handling
python manage.py load_claims_data --verbosity=3
```

**Usage Scenarios**:
- **Initial Setup**: Load existing legacy data into Django
- **Data Migration**: Transfer data from old system
- **Development**: Populate test database with real data
- **Production**: Migrate production data to new system

#### 2. Reload Claims Data Command (`reload_claims_data`)
**Purpose**: Load data from CSV files with flexible options

**Basic Execution**:
```bash
python manage.py reload_claims_data
```

**Mode Options**:
```bash
# Overwrite mode (default) - replaces all existing data
python manage.py reload_claims_data --mode overwrite

# Append mode - adds new data while preserving existing
python manage.py reload_claims_data --mode append
```

**File Path Options**:
```bash
# Use default file paths (Data/claim_list_data.csv, Data/claim_detail_data.csv)
python manage.py reload_claims_data --mode overwrite

# Custom claim list file
python manage.py reload_claims_data --mode overwrite --claim-list /path/to/custom_claims.csv

# Custom claim detail file
python manage.py reload_claims_data --mode overwrite --claim-detail /path/to/custom_details.csv

# Both custom files
python manage.py reload_claims_data --mode overwrite --claim-list /path/to/claims.csv --claim-detail /path/to/details.csv
```

**Advanced Usage**:
```bash
# Verbose output with custom files
python manage.py reload_claims_data --mode append --claim-list /data/claims.csv --claim-detail /data/details.csv --verbosity=2

# Overwrite with specific files and detailed logging
python manage.py reload_claims_data --mode overwrite --claim-list ./imports/new_claims.csv --claim-detail ./imports/new_details.csv --verbosity=3
```

**Usage Scenarios**:
- **Data Updates**: Replace existing data with new CSV files
- **Incremental Loading**: Add new claims without affecting existing ones
- **Testing**: Load different datasets for testing
- **Production Updates**: Update production data from external sources

### Execution Examples by Use Case

#### Development Environment Setup
```bash
# 1. Load initial data from existing database
python manage.py load_claims_data

# 2. Verify data loaded correctly
python manage.py shell
>>> from claims.models import ClaimList, ClaimDetail
>>> print(f"Claims: {ClaimList.objects.count()}, Details: {ClaimDetail.objects.count()}")
```

#### Production Data Update
```bash
# 1. Backup existing data (recommended)
python manage.py dumpdata claims > backup_$(date +%Y%m%d).json

# 2. Load new data with overwrite
python manage.py reload_claims_data --mode overwrite --claim-list /production/new_claims.csv --claim-detail /production/new_details.csv

# 3. Verify update
python manage.py shell
>>> from claims.models import ClaimList
>>> print(f"Total claims: {ClaimList.objects.count()}")
```

#### Testing Different Datasets
```bash
# Load test dataset A
python manage.py reload_claims_data --mode overwrite --claim-list ./test_data/dataset_a_claims.csv --claim-detail ./test_data/dataset_a_details.csv

# Load test dataset B
python manage.py reload_claims_data --mode overwrite --claim-list ./test_data/dataset_b_claims.csv --claim-detail ./test_data/dataset_b_details.csv
```

#### Incremental Data Loading
```bash
# Add new claims without affecting existing ones
python manage.py reload_claims_data --mode append --claim-list ./new_claims.csv --claim-detail ./new_details.csv
```

### Error Handling and Troubleshooting

#### Common Issues and Solutions

**File Not Found Error**:
```bash
# Error: File not found
python manage.py reload_claims_data --claim-list /wrong/path/file.csv
# Solution: Check file path and permissions
ls -la /correct/path/file.csv
```

**Data Type Conversion Errors**:
```bash
# Error: Invalid date format
# Solution: Ensure dates are in YYYY-MM-DD format
# Example: 2024-01-15 (not 01/15/2024)
```

**Permission Issues**:
```bash
# Error: Permission denied
# Solution: Check file permissions
chmod 644 /path/to/csv/file.csv
```

#### Debugging Commands
```bash
# Check command help
python manage.py load_claims_data --help
python manage.py reload_claims_data --help

# Verbose execution for debugging
python manage.py reload_claims_data --mode overwrite --verbosity=3

# Test with small dataset first
python manage.py reload_claims_data --mode overwrite --claim-list ./small_test.csv
```

### Performance Optimization

#### Large Dataset Handling
```bash
# For datasets > 10,000 records
# Use batch processing
python manage.py reload_claims_data --mode overwrite --verbosity=1

# Monitor memory usage
top -p $(pgrep python)
```

#### Database Optimization
```bash
# Before loading large datasets
python manage.py shell
>>> from django.db import connection
>>> connection.ensure_connection()

# After loading
python manage.py shell
>>> from django.db import connection
>>> connection.close()
```

### Additional Django Commands

#### Database Management
```bash
# Create database tables
python manage.py makemigrations
python manage.py migrate

# Reset database (WARNING: deletes all data)
python manage.py flush

# Create superuser
python manage.py createsuperuser

# Backup data
python manage.py dumpdata claims > backup.json

# Restore data
python manage.py loaddata backup.json
```

#### Development Commands
```bash
# Run development server
python manage.py runserver

# Run on specific port
python manage.py runserver 8080

# Run on all interfaces
python manage.py runserver 0.0.0.0:8000

# Start Django shell
python manage.py shell

# Collect static files
python manage.py collectstatic

# Check for problems
python manage.py check
```

#### Testing Commands
```bash
# Run all tests
python manage.py test

# Run specific app tests
python manage.py test claims

# Run with coverage
coverage run --source='.' manage.py test
coverage report

# Run specific test
python manage.py test claims.tests.TestClaimList
```

## üîß All Scripts & Utilities

### Management Commands (Django)

#### 1. `load_claims_data.py` - Data Migration Script
**Location**: `claims/management/commands/load_claims_data.py`

**Purpose**: Migrate data from existing SQLite database to Django models

**Execution**:
```bash
python manage.py load_claims_data
```

**What it does**:
- Connects to existing SQLite database (`claims.db`)
- Extracts data from `claim_list` and `claim_detail` tables
- Converts data types (strings to dates, amounts to decimals)
- Uses `bulk_create` for optimal performance
- Clears existing Django model data before loading
- Handles data validation and error logging

**Code Structure**:
```python
class Command(BaseCommand):
    help = 'Load claims data from existing SQLite database into Django models'
    
    def handle(self, *args, **options):
        # Load claim list data
        self.load_claim_list_data()
        # Load claim detail data  
        self.load_claim_detail_data()
```

**Usage Scenarios**:
- **Initial Setup**: Load existing legacy data into Django
- **Data Migration**: Transfer data from old system
- **Development**: Populate test database with real data
- **Production**: Migrate production data to new system

#### 2. `reload_claims_data.py` - CSV Data Loading Script
**Location**: `claims/management/commands/reload_claims_data.py`

**Purpose**: Load data from CSV files with flexible options

**Execution**:
```bash
# Basic usage
python manage.py reload_claims_data

# With options
python manage.py reload_claims_data --mode overwrite --claim-list path/to/claims.csv
```

**Command Line Arguments**:
- `--mode`: `overwrite` (default) or `append`
- `--claim-list`: Path to claim list CSV file
- `--claim-detail`: Path to claim detail CSV file

**What it does**:
- Reads CSV files using pandas
- Supports overwrite or append modes
- Handles custom file paths
- Uses bulk operations for performance
- Provides detailed progress feedback

**Code Structure**:
```python
class Command(BaseCommand):
    def add_arguments(self, parser):
        parser.add_argument('--mode', choices=['overwrite', 'append'])
        parser.add_argument('--claim-list', type=str)
        parser.add_argument('--claim-detail', type=str)
    
    def handle(self, *args, **options):
        # Process CSV files and load data
```

**Usage Scenarios**:
- **Data Updates**: Replace existing data with new CSV files
- **Incremental Loading**: Add new claims without affecting existing ones
- **Testing**: Load different datasets for testing
- **Production Updates**: Update production data from external sources

### Utility Scripts (Standalone)

#### 3. `database.py` - CSV to SQLite Converter
**Location**: `database.py`

**Purpose**: Convert CSV files to SQLite database

**Execution**:
```bash
python database.py
```

**What it does**:
- Reads CSV files from `Data/` directory
- Creates SQLite database (`claims.db`)
- Converts CSV data to database tables
- Handles pipe-delimited CSV format
- Provides detailed progress feedback

**Code Structure**:
```python
def push_csv_to_sqlite(db_name='claims.db'):
    """Reads CSV files and pushes to SQLite database"""
    # Load CSV files with pandas
    # Create SQLite connection
    # Write DataFrames to tables
    # Handle errors and cleanup
```

**Usage Scenarios**:
- **Initial Data Setup**: Convert CSV files to database
- **Data Migration**: Prepare data for Django import
- **Testing**: Create test databases from CSV files
- **Backup**: Convert data back to database format

**File Requirements**:
- `Data/claim_list_data.csv` (pipe-delimited)
- `Data/claim_detail_data.csv` (pipe-delimited)

#### 4. `check_db.py` - Database Inspection Script
**Location**: `check_db.py`

**Purpose**: Inspect SQLite database structure and content

**Execution**:
```bash
python check_db.py
```

**What it does**:
- Connects to SQLite database (`claims.db`)
- Lists all tables in database
- Counts records in each table
- Shows sample data from tables
- Provides database health check

**Code Structure**:
```python
import sqlite3

conn = sqlite3.connect('claims.db')
cursor = conn.cursor()

# Check tables
cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")

# Check data counts
cursor.execute("SELECT COUNT(*) FROM claim_list")
cursor.execute("SELECT COUNT(*) FROM claim_detail")

# Show sample data
cursor.execute("SELECT * FROM claim_list LIMIT 3")
```

**Usage Scenarios**:
- **Database Verification**: Check if data loaded correctly
- **Debugging**: Inspect database structure and content
- **Data Validation**: Verify data integrity
- **Development**: Quick database health checks

#### 5. `debug_db.py` - Django Database Debug Script
**Location**: `debug_db.py`

**Purpose**: Test Django database connectivity and models

**Execution**:
```bash
python debug_db.py
```

**What it does**:
- Sets up Django environment
- Tests direct database connection
- Compares raw SQL vs Django ORM
- Tests model creation and queries
- Provides detailed debugging information

**Code Structure**:
```python
import os
import django

# Setup Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'claims_interface.settings')
django.setup()

from django.db import connection
from claims.models import ClaimList, ClaimDetail

# Test direct database connection
cursor = connection.cursor()
cursor.execute("SELECT COUNT(*) FROM claim_list")

# Test Django models
django_claim_list_count = ClaimList.objects.count()

# Try to create test records
test_claim = ClaimList(...)
test_claim.save()
```

**Usage Scenarios**:
- **Django Setup Verification**: Test Django configuration
- **Model Testing**: Verify Django models work correctly
- **Database Connectivity**: Test database connections
- **Development Debugging**: Debug Django database issues

#### 6. `test_django_db.py` - Django ORM Testing Script
**Location**: `test_django_db.py`

**Purpose**: Comprehensive Django ORM and database testing

**Execution**:
```bash
python test_django_db.py
```

**What it does**:
- Sets up Django environment
- Tests raw SQL queries vs Django ORM
- Compares query results
- Tests record creation and retrieval
- Provides detailed comparison analysis

**Code Structure**:
```python
import os
import django

# Setup Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'claims_interface.settings')
django.setup()

from django.db import connection
from claims.models import ClaimList, ClaimDetail

# Test raw SQL query
cursor = connection.cursor()
cursor.execute("SELECT COUNT(*) FROM claim_list")
raw_count = cursor.fetchone()[0]

# Test Django ORM
orm_count = ClaimList.objects.count()

# Compare results and test operations
```

**Usage Scenarios**:
- **ORM Testing**: Verify Django ORM functionality
- **Performance Comparison**: Compare raw SQL vs ORM
- **Data Integrity**: Verify data consistency
- **Development Testing**: Test database operations

### Script Execution Patterns

#### Data Loading Workflow
```bash
# 1. Convert CSV to SQLite (if needed)
python database.py

# 2. Verify database structure
python check_db.py

# 3. Load data into Django
python manage.py load_claims_data

# 4. Test Django models
python debug_db.py
python test_django_db.py
```

#### Development Testing Workflow
```bash
# 1. Check database health
python check_db.py

# 2. Test Django setup
python debug_db.py

# 3. Test ORM operations
python test_django_db.py

# 4. Run Django management commands
python manage.py load_claims_data
python manage.py reload_claims_data --mode overwrite
```

#### Production Data Update Workflow
```bash
# 1. Backup existing data
python manage.py dumpdata claims > backup_$(date +%Y%m%d).json

# 2. Load new data
python manage.py reload_claims_data --mode overwrite --claim-list /new/claims.csv

# 3. Verify data integrity
python check_db.py
python debug_db.py
```

### Script Dependencies

#### Required Python Packages
```bash
# Core dependencies
pip install django==4.2.7
pip install pandas==2.1.3

# Optional dependencies
pip install python-dotenv==1.0.0
pip install django-crispy-forms==2.1
pip install crispy-bootstrap5==0.7
```

#### File Dependencies
- **CSV Files**: `Data/claim_list_data.csv`, `Data/claim_detail_data.csv`
- **Database**: `claims.db` (SQLite)
- **Django Settings**: `claims_interface/settings.py`
- **Models**: `claims/models.py`

### Error Handling & Troubleshooting

#### Common Script Errors

**File Not Found Errors**:
```bash
# Error: CSV files not found
# Solution: Ensure Data/ directory exists with CSV files
ls -la Data/
```

**Database Connection Errors**:
```bash
# Error: Database locked or not found
# Solution: Check file permissions and path
ls -la claims.db
chmod 644 claims.db
```

**Django Import Errors**:
```bash
# Error: Django not found
# Solution: Install Django and set up environment
pip install django
export DJANGO_SETTINGS_MODULE=claims_interface.settings
```

**Model Import Errors**:
```bash
# Error: Models not found
# Solution: Ensure Django is set up correctly
python manage.py check
python manage.py makemigrations
python manage.py migrate
```

#### Debugging Commands
```bash
# Check script help
python manage.py load_claims_data --help
python manage.py reload_claims_data --help

# Verbose execution
python manage.py load_claims_data --verbosity=3
python manage.py reload_claims_data --mode overwrite --verbosity=3

# Test individual components
python check_db.py
python debug_db.py
python test_django_db.py
```

### Performance Optimization

#### Large Dataset Handling
```bash
# For datasets > 10,000 records
# Use batch processing
python manage.py reload_claims_data --mode overwrite --verbosity=1

# Monitor memory usage
top -p $(pgrep python)
```

#### Database Optimization
```bash
# Before loading large datasets
python manage.py shell
>>> from django.db import connection
>>> connection.ensure_connection()

# After loading
python manage.py shell
>>> from django.db import connection
>>> connection.close()
```

### Script Maintenance

#### Regular Tasks
- **Update Dependencies**: Keep Django and pandas updated
- **Test Scripts**: Run all scripts after updates
- **Backup Data**: Regular database backups
- **Monitor Performance**: Track script execution times
- **Update Documentation**: Keep script documentation current

#### Version Control
```bash
# Track script changes
git add *.py
git commit -m "Update database scripts"

# Tag releases
git tag v1.0.0
git push origin v1.0.0
```

## üèÉ‚Äç‚ôÇÔ∏è Running the Application

### Development Server
```bash
python manage.py runserver
```
Access the application at `http://127.0.0.1:8000`

### Production Deployment
1. Set `DEBUG = False` in `settings.py`
2. Configure your production database
3. Set up static file serving
4. Use a production WSGI server (Gunicorn, uWSGI)

## üéØ Usage Guide

### 1. Authentication
- Navigate to `/login/`
- Enter your credentials
- System redirects to dashboard after successful login

### 2. Dashboard Overview
- **Total Claims**: Shows count of all claims
- **Total Amount**: Sum of all billed amounts
- **Average Claim**: Average billed amount per claim
- **Flagged Claims**: Number of claims flagged for review
- **Charts**: Visual representation of claims by status and insurer

### 3. Claims List
- **URL**: `/dashboard/claims/`
- **Features**:
  - Search by ID, patient name, or insurer
  - Filter by status or policy
  - Pagination (25 claims per page)
  - Sort by various columns

### 4. Claim Details
- **URL**: `/dashboard/claims/<claim_id>/`
- **Features**:
  - Complete claim information
  - CPT codes and denial reasons
  - Financial summary
  - Flag and note management
  - CSV export functionality

### 5. HTMX Integration
- **Real-time Updates**: Claim details update without page reload
- **Dynamic Forms**: Add flags and notes with instant feedback
- **Smooth UX**: No full page refreshes for better performance

### 6. Flagging Claims
1. Navigate to claim detail page
2. Click "Flag for Review"
3. Enter reason for flagging
4. Flag appears in dashboard statistics

### 7. Adding Notes
1. Go to claim detail page
2. Scroll to "Notes" section
3. Enter note text
4. Submit to save with timestamp

### 8. Analytics
- **URL**: `/dashboard/analytics/`
- **Features**:
  - Claims by month chart
  - Status distribution
  - Top insurers by payment
  - Financial trends

## üêç Python Functionalities

### Core Application Structure

#### Django Project (`claims_interface/`)
- **`settings.py`**: Main configuration file with database, authentication, and app settings
- **`urls.py`**: Root URL configuration and authentication routing
- **`wsgi.py`**: WSGI application entry point for production deployment
- **`asgi.py`**: ASGI application entry point for async support
- **`middleware.py`**: Custom middleware for authentication and request processing

#### Claims App (`claims/`)
- **`models.py`**: Database models and business logic
- **`views.py`**: HTTP request handlers and view logic
- **`urls.py`**: URL routing for claims functionality
- **`admin.py`**: Django admin interface configuration
- **`apps.py`**: App configuration and metadata

## üîß Detailed Functionalities

### 1. Data Ingestion & Management

#### CSV Data Loading
- **File Format Support**: Pipe-delimited CSV files
- **Data Validation**: Automatic type conversion and validation
- **Bulk Operations**: Efficient bulk_create for large datasets
- **Error Handling**: Graceful handling of malformed data
- **Mode Options**: Overwrite or append existing data

#### Database Migration
- **SQLite to Django**: Migrate existing SQLite data to Django models
- **Data Type Conversion**: Automatic conversion of data types
- **Bulk Processing**: Handle thousands of records efficiently
- **Progress Tracking**: Real-time progress updates during migration

### 2. Claims Management System

#### Claims List Functionality
- **Search Capability**: Search by claim ID, patient name, or insurer
- **Advanced Filtering**: Filter by status, policy, date ranges
- **Pagination**: 25 records per page with navigation
- **Sorting**: Sort by any column (ID, amount, date, status)
- **Real-time Updates**: HTMX-powered dynamic list updates

#### Claim Detail System
- **Complete Information Display**: All claim data in organized layout
- **CPT Codes Display**: Medical procedure codes with formatting
- **Denial Reasons**: Detailed denial information with categorization
- **Financial Summary**: Billed vs paid amounts with calculations
- **Export Functionality**: CSV export for individual claims

### 3. Flagging & Annotation System

#### Flag Management
- **Flag Creation**: Users can flag claims for review
- **Reason Tracking**: Store detailed reasons for flagging
- **Status Tracking**: Track resolved vs unresolved flags
- **User Association**: Link flags to specific users
- **Resolution System**: Mark flags as resolved with timestamps

#### Note System
- **Note Creation**: Add detailed notes to any claim
- **User Ownership**: Notes linked to creating user
- **Edit Capability**: Users can edit their own notes
- **Timestamp Tracking**: Automatic creation and update timestamps
- **Admin Override**: Admins can manage all notes

### 4. Search & Filter System

#### Advanced Search
- **Multi-field Search**: Search across ID, name, insurer simultaneously
- **Partial Matching**: Case-insensitive partial text matching
- **Real-time Results**: Instant search results with HTMX
- **Search History**: Maintain search state across page loads

#### Filter System
- **Status Filtering**: Filter by claim status (Paid, Denied, Under Review)
- **Insurer Filtering**: Filter by specific insurance companies
- **Date Range Filtering**: Filter by discharge date ranges
- **Combined Filters**: Multiple filters work together

### 5. Analytics & Reporting

#### Dashboard Analytics
- **Total Claims Count**: Real-time count of all claims
- **Financial Totals**: Sum of billed and paid amounts
- **Average Calculations**: Average claim amounts
- **Flagged Claims Count**: Number of unresolved flags
- **Recent Activity**: Latest claims and updates

#### Advanced Analytics
- **Claims by Month**: Monthly claim volume analysis
- **Status Distribution**: Pie charts showing claim status breakdown
- **Top Insurers**: Ranking of insurers by payment volume
- **Financial Trends**: Payment patterns over time
- **Underpayment Analysis**: Average underpayment calculations

### 6. User Authentication & Security

#### Authentication System
- **Login Required**: All views require authentication
- **Session Management**: Secure session handling
- **User Permissions**: Role-based access control
- **Password Security**: Django's built-in password validation
- **Logout Functionality**: Secure logout with session cleanup

#### Security Features
- **CSRF Protection**: All forms protected against CSRF attacks
- **SQL Injection Prevention**: Django ORM protection
- **Input Validation**: Server-side validation of all inputs
- **XSS Protection**: Automatic HTML escaping
- **Secure Headers**: Security headers for production

### 7. Real-time Updates (HTMX)

#### Dynamic Content Updates
- **Partial Page Updates**: Update specific sections without full reload
- **Form Submissions**: Real-time form processing
- **Search Results**: Instant search result updates
- **Flag/Note Updates**: Immediate display of new flags and notes
- **Status Changes**: Real-time status updates

#### HTMX Integration
- **Event Handling**: Proper event handling for dynamic content
- **Error Handling**: Graceful error display for failed requests
- **Loading States**: Visual feedback during requests
- **State Management**: Maintain application state across updates

### 8. Export & Data Management

#### CSV Export System
- **Individual Claim Export**: Export single claim to CSV
- **Complete Data Export**: Export all claim data
- **Formatted Output**: Properly formatted CSV with headers
- **Error Handling**: Handle export failures gracefully
- **File Download**: Proper file download with correct headers

#### Data Management
- **Bulk Operations**: Efficient handling of large datasets
- **Data Validation**: Validate data before saving
- **Error Recovery**: Recover from data loading errors
- **Progress Tracking**: Show progress during data operations

### 9. Mobile Responsive Design

#### Responsive Layout
- **Mobile Navigation**: Collapsible sidebar for mobile devices
- **Touch-friendly Interface**: Large buttons and touch targets
- **Responsive Tables**: Tables that work on small screens
- **Flexible Grid**: Bootstrap grid system for all screen sizes
- **Mobile Optimized**: Optimized for mobile performance

#### UI/UX Features
- **Modern Design**: Clean, professional interface
- **Loading Indicators**: Visual feedback for operations
- **Error Messages**: Clear, user-friendly error messages
- **Success Notifications**: Confirm successful operations
- **Accessibility**: WCAG compliant design elements

### 10. Performance Optimizations

#### Database Optimizations
- **Bulk Operations**: Use bulk_create for data loading
- **Query Optimization**: Optimized database queries
- **Indexing**: Proper database indexing
- **Connection Pooling**: Efficient database connections
- **Caching**: Strategic caching of frequently accessed data

#### Frontend Optimizations
- **HTMX Efficiency**: Reduce server load with partial updates
- **Alpine.js Performance**: Lightweight JavaScript framework
- **Bootstrap Optimization**: Efficient CSS framework usage
- **Asset Optimization**: Minimized and compressed assets
- **Lazy Loading**: Load content as needed

### 11. Error Handling & Logging

#### Comprehensive Error Handling
- **Exception Catching**: Catch and handle all exceptions
- **User-friendly Messages**: Clear error messages for users
- **Logging System**: Detailed logging for debugging
- **Graceful Degradation**: System continues working despite errors
- **Error Recovery**: Automatic recovery from common errors

#### Monitoring & Debugging
- **Development Tools**: Django debug toolbar integration
- **Performance Monitoring**: Track response times and queries
- **Error Tracking**: Monitor and log all errors
- **User Feedback**: Collect user feedback on issues
- **System Health**: Monitor system health and performance

### 12. Admin Interface

#### Django Admin Integration
- **Model Management**: Full CRUD operations for all models
- **User Management**: Create and manage users
- **Permission System**: Manage user permissions
- **Bulk Actions**: Perform bulk operations on data
- **Data Export**: Export data through admin interface

#### Custom Admin Features
- **Custom Actions**: Custom admin actions for common tasks
- **Filtered Views**: Advanced filtering in admin
- **Search Capability**: Search across all admin models
- **Audit Trail**: Track changes made through admin
- **Data Validation**: Admin-side data validation

### 13. API Endpoints

#### RESTful API
- **Claims Data API**: JSON endpoint for claims data
- **Chart Data API**: Data for JavaScript charts
- **Search API**: Programmatic search functionality
- **Export API**: API-driven data export
- **Authentication**: Secure API authentication

#### API Features
- **JSON Response**: Clean JSON responses
- **Error Handling**: Proper HTTP error codes
- **Rate Limiting**: Prevent API abuse
- **Documentation**: API documentation and examples
- **Versioning**: API version management

### 14. Testing & Quality Assurance

#### Testing Framework
- **Unit Tests**: Test individual functions and methods
- **Integration Tests**: Test complete workflows
- **Model Tests**: Test database models and relationships
- **View Tests**: Test HTTP request handling
- **Form Tests**: Test form validation and processing

#### Quality Assurance
- **Code Coverage**: Maintain high test coverage
- **Code Quality**: Follow PEP 8 and Django best practices
- **Documentation**: Comprehensive code documentation
- **Type Hints**: Python type hints for better code clarity
- **Linting**: Automated code linting and formatting

### Database Models (`claims/models.py`)

#### ClaimList Model
```python
class ClaimList(models.Model):
    """Main claims data model"""
    id = models.BigIntegerField(primary_key=True)
    patient_name = models.CharField(max_length=255)
    billed_amount = models.DecimalField(max_digits=15, decimal_places=2)
    paid_amount = models.DecimalField(max_digits=15, decimal_places=2)
    status = models.CharField(max_length=100)
    insurer_name = models.CharField(max_length=255)
    discharge_date = models.DateField()
```
**Purpose**: Stores primary claim information including patient details, financial data, and claim status.

#### ClaimDetail Model
```python
class ClaimDetail(models.Model):
    """Detailed claim information including CPT codes and denial reasons"""
    id = models.IntegerField(primary_key=True)
    claim_id = models.BigIntegerField()
    denial_reason = models.CharField(max_length=500)
    cpt_codes = models.CharField(max_length=500)
```
**Purpose**: Stores detailed claim information like CPT codes and denial reasons linked to main claims.

#### ClaimFlag Model
```python
class ClaimFlag(models.Model):
    """System for flagging claims for review"""
    claim = models.ForeignKey(ClaimList, on_delete=models.CASCADE)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    flagged_at = models.DateTimeField(auto_now_add=True)
    reason = models.CharField(max_length=500)
    is_resolved = models.BooleanField(default=False)
    resolved_at = models.DateTimeField(blank=True, null=True)
    resolved_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True)
```
**Purpose**: Allows users to flag claims for review with tracking of resolution status.

#### ClaimNote Model
```python
class ClaimNote(models.Model):
    """User notes and annotations for claims"""
    claim = models.ForeignKey(ClaimList, on_delete=models.CASCADE)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    note = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
```
**Purpose**: Enables users to add notes and annotations to claims with timestamp tracking.

### View Functions (`claims/views.py`)

#### Dashboard Views
- **`dashboard(request)`**: Main dashboard with summary statistics and charts
  - Calculates total claims, amounts, averages
  - Shows flagged claims count
  - Displays claims by status and insurer
  - Provides recent claims list

- **`analytics(request)`**: Advanced analytics and reporting
  - Claims by month analysis
  - Status distribution charts
  - Top insurers by payment
  - Financial trend analysis

#### Claims Management Views
- **`claim_list(request)`**: Lists all claims with search and filtering
  - Search by ID, patient name, or insurer
  - Filter by status or policy
  - Pagination (25 records per page)
  - Sort functionality

- **`claim_detail(request, claim_id)`**: Detailed view of specific claim
  - Complete claim information display
  - CPT codes and denial reasons
  - Financial summary
  - CSV export functionality
  - Flag and note management

- **`claim_detail_htmx(request, claim_id)`**: HTMX partial for dynamic updates
  - Real-time claim detail updates
  - No full page reload required
  - Optimized for HTMX requests

- **`claim_details_list(request)`**: Lists all claim details
  - Search by claim ID, denial reason, or CPT codes
  - Filter by denial reason
  - Pagination support

#### Flag and Note Management Views
- **`flag_claim(request, claim_id)`**: Flag a claim for review
  - Creates new flag with reason
  - Links to user who created flag
  - Supports HTMX updates

- **`resolve_flag(request, flag_id)`**: Mark flag as resolved
  - Updates flag status
  - Records resolution timestamp and user
  - Prevents duplicate resolutions

- **`delete_flag(request, flag_id)`**: Remove a flag
  - User permission checking
  - Admin override capability
  - Redirects to claim detail

- **`add_note(request, claim_id)`**: Add note to claim
  - Creates new note with timestamp
  - User association
  - HTMX support for real-time updates

- **`edit_note(request, note_id)`**: Edit existing note
  - User permission validation
  - Update timestamp tracking
  - Form-based editing

- **`delete_note(request, note_id)`**: Remove note
  - User ownership validation
  - Admin deletion capability
  - Proper cleanup

#### API Views
- **`api_claims_data(request)`**: JSON API for charts
  - Returns claims data for JavaScript charts
  - Excludes test insurers
  - Aggregated status data

### Management Commands (`claims/management/commands/`)

#### Data Loading Commands
- **`load_claims_data.py`**: Load data from existing SQLite database
  ```python
  class Command(BaseCommand):
      def handle(self, *args, **options):
          # Loads data from existing database into Django models
          # Handles data type conversions
          # Uses bulk_create for performance
  ```
  **Purpose**: Migrates existing data from SQLite to Django models with proper data type handling.

- **`reload_claims_data.py`**: Load data from CSV files
  ```python
  class Command(BaseCommand):
      def add_arguments(self, parser):
          # Command line arguments for mode and file paths
      def handle(self, *args, **options):
          # Supports overwrite/append modes
          # Handles custom file paths
          # Uses pandas for CSV processing
  ```
  **Purpose**: Flexible data ingestion from CSV files with overwrite/append options.

### URL Configuration (`claims/urls.py`)
```python
urlpatterns = [
    path('', views.dashboard, name='dashboard'),
    path('claims/', views.claim_list, name='claim_list'),
    path('claims/<str:claim_id>/', views.claim_detail, name='claim_detail'),
    path('claims/<str:claim_id>/htmx/', views.claim_detail_htmx, name='claim_detail_htmx'),
    path('claims/<str:claim_id>/flag/', views.flag_claim, name='flag_claim'),
    path('claims/<str:claim_id>/note/', views.add_note, name='add_note'),
    path('flags/<int:flag_id>/resolve/', views.resolve_flag, name='resolve_flag'),
    path('flags/<int:flag_id>/delete/', views.delete_flag, name='delete_flag'),
    path('notes/<int:note_id>/edit/', views.edit_note, name='edit_note'),
    path('notes/<int:note_id>/delete/', views.delete_note, name='delete_note'),
    path('claim-details/', views.claim_details_list, name='claim_details_list'),
    path('analytics/', views.analytics, name='analytics'),
    path('api/claims-data/', views.api_claims_data, name='api_claims_data'),
]
```

### Admin Configuration (`claims/admin.py`)
- **Django Admin Interface**: Provides web-based database management
- **Model Registration**: All models registered for admin access
- **Custom Admin Actions**: Bulk operations and data management
- **User Management**: User creation and permission management

### Authentication System
- **Django Built-in Auth**: Uses Django's authentication framework
- **Login Required Decorator**: All views require authentication
- **User Permissions**: Role-based access control
- **Session Management**: Secure session handling

### Data Processing Functions

#### CSV Processing (`reload_claims_data.py`)
```python
def process_csv_data(csv_path, model_class):
    """Process CSV data with pandas"""
    df = pd.read_csv(csv_path, delimiter='|')
    objects = []
    for _, row in df.iterrows():
        # Convert data types and create objects
        objects.append(model_class(**row_dict))
    return objects
```
**Purpose**: Efficient CSV data processing with pandas for bulk operations.

#### Database Operations
```python
def bulk_create_with_validation(objects, model_class):
    """Bulk create with error handling"""
    try:
        model_class.objects.bulk_create(objects, ignore_conflicts=True)
        return len(objects)
    except Exception as e:
        logger.error(f"Bulk create failed: {e}")
        return 0
```
**Purpose**: Optimized database operations with error handling and logging.

### Utility Functions

#### Data Validation
```python
def validate_claim_data(claim_data):
    """Validate claim data before saving"""
    required_fields = ['id', 'patient_name', 'billed_amount']
    for field in required_fields:
        if field not in claim_data or not claim_data[field]:
            return False
    return True
```
**Purpose**: Ensures data integrity before database operations.

#### Financial Calculations
```python
def calculate_underpayment(billed, paid):
    """Calculate underpayment amount"""
    if billed and paid:
        return billed - paid
    return 0
```
**Purpose**: Handles financial calculations for analytics and reporting.

### Error Handling
- **Exception Handling**: Comprehensive try-catch blocks
- **Logging**: Detailed logging for debugging
- **User Feedback**: Informative error messages
- **Graceful Degradation**: System continues working despite errors

### Performance Optimizations
- **Bulk Operations**: Uses `bulk_create` for data loading
- **Database Queries**: Optimized queries with `select_related`
- **Pagination**: Prevents memory issues with large datasets
- **Caching**: Strategic caching for frequently accessed data

## üóÑÔ∏è Database Schema

### Models

#### ClaimList
- `id` (BigIntegerField, Primary Key)
- `patient_name` (CharField)
- `billed_amount` (DecimalField)
- `paid_amount` (DecimalField)
- `status` (CharField)
- `insurer_name` (CharField)
- `discharge_date` (DateField)

#### ClaimDetail
- `id` (IntegerField, Primary Key)
- `claim_id` (BigIntegerField, Foreign Key to ClaimList)
- `denial_reason` (CharField)
- `cpt_codes` (CharField)

#### ClaimFlag
- `claim` (ForeignKey to ClaimList)
- `user` (ForeignKey to User)
- `flagged_at` (DateTimeField)
- `reason` (CharField)
- `is_resolved` (BooleanField)
- `resolved_at` (DateTimeField)
- `resolved_by` (ForeignKey to User)

#### ClaimNote
- `claim` (ForeignKey to ClaimList)
- `user` (ForeignKey to User)
- `note` (TextField)
- `created_at` (DateTimeField)
- `updated_at` (DateTimeField)

## üîß Configuration

### Settings (`claims_interface/settings.py`)
- **Database**: SQLite by default, easily configurable for PostgreSQL
- **Authentication**: Django's built-in authentication system
- **Static Files**: Configured for development and production
- **Crispy Forms**: Bootstrap 5 styling

### Environment Variables
Create a `.env` file for production:
```env
SECRET_KEY=your-secret-key-here
DEBUG=False
DATABASE_URL=postgresql://user:password@localhost/dbname
```

## üß™ Testing

### Run Tests
```bash
python manage.py test
```

### Test Data
- Sample data available in `Data/` directory
- Management commands for loading test data
- Factory patterns for generating test data

## üìà Performance

### Optimizations
- **Bulk Operations**: Uses `bulk_create` for data loading
- **Database Indexing**: Proper indexing on frequently queried fields
- **Pagination**: 25 records per page to prevent memory issues
- **HTMX**: Reduces server load with partial page updates

### Monitoring
- Django Debug Toolbar (development)
- Database query optimization
- Memory usage monitoring

## üîí Security

### Features
- **CSRF Protection**: Enabled on all forms
- **Authentication Required**: All views require login
- **User Permissions**: Role-based access control
- **Input Validation**: Django form validation
- **SQL Injection Protection**: Django ORM

### Best Practices
- Use HTTPS in production
- Regular security updates
- Database backup procedures
- User session management

## üöÄ Deployment to Render

### Quick Deploy to Render

This Django Claims Management System is optimized for deployment on Render. Follow these steps to deploy your application:

#### 1. Prepare Your Repository

Ensure your repository contains these files:
- `render.yaml` - Render configuration
- `requirements.txt` - Python dependencies
- `build.sh` - Build script
- `claims_interface/settings.py` - Updated for production

#### 2. Deploy to Render

**Option A: Using Render Dashboard (Recommended)**

1. **Sign up/Login to Render**
   - Go to [render.com](https://render.com)
   - Create account or login

2. **Create New Web Service**
   - Click "New +" ‚Üí "Web Service"
   - Connect your GitHub repository
   - Select your repository

3. **Configure Service**
   - **Name**: `claims-management-system`
   - **Environment**: `Python 3`
   - **Build Command**: `./build.sh`
   - **Start Command**: `gunicorn claims_interface.wsgi:application`

4. **Environment Variables**
   Add these in the Render dashboard:
   ```
   SECRET_KEY=your-secret-key-here
   DEBUG=False
   ALLOWED_HOSTS=.onrender.com
   ```

5. **Deploy**
   - Click "Create Web Service"
   - Wait for build to complete (2-3 minutes)

**Option B: Using render.yaml (Blue-Green Deploy)**

1. **Push to GitHub**
   ```bash
   git add .
   git commit -m "Add Render deployment configuration"
   git push origin main
   ```

2. **Connect Repository**
   - Go to Render Dashboard
   - Click "New +" ‚Üí "Blueprint"
   - Connect your repository
   - Render will automatically detect `render.yaml`

3. **Deploy**
   - Click "Create Blueprint Instance"
   - Render will create the service automatically

#### 3. Post-Deployment Setup

After successful deployment:

1. **Create Superuser**
   ```bash
   # Access your Render service shell
   # Go to your service ‚Üí Shell
   python manage.py createsuperuser
   ```

2. **Load Sample Data**
   ```bash
   # In Render shell
   python manage.py load_claims_data
   ```

3. **Verify Deployment**
   - Visit your Render URL
   - Test login functionality
   - Check all features work correctly

### Render Configuration Files

#### `render.yaml`
```yaml
services:
  - type: web
    name: claims-management-system
    env: python
    plan: free
    buildCommand: pip install -r requirements.txt
    startCommand: gunicorn claims_interface.wsgi:application
    envVars:
      - key: PYTHON_VERSION
        value: 3.9.16
      - key: DJANGO_SETTINGS_MODULE
        value: claims_interface.settings
      - key: SECRET_KEY
        generateValue: true
      - key: DEBUG
        value: False
      - key: ALLOWED_HOSTS
        value: .onrender.com
    healthCheckPath: /
    autoDeploy: true
```

#### `build.sh`
```bash
#!/usr/bin/env bash
# exit on error
set -o errexit

pip install -r requirements.txt
python manage.py collectstatic --no-input
python manage.py migrate
```

#### Updated `requirements.txt`
```
Django==4.2.7
pandas==2.1.3
python-dotenv==1.0.0
django-crispy-forms==2.1
crispy-bootstrap5==0.7
gunicorn==21.2.0
whitenoise==6.6.0
```

### Environment Variables

#### Required Variables
- `SECRET_KEY`: Django secret key (auto-generated by Render)
- `DEBUG`: Set to `False` for production
- `ALLOWED_HOSTS`: Set to `.onrender.com` for Render domains

#### Optional Variables
- `DATABASE_URL`: For external database (if using PostgreSQL)
- `STATIC_URL`: Static files URL (default: `/static/`)

### Production Settings

The application is configured for production with:

1. **Security Settings**
   - `DEBUG = False`
   - CSRF protection enabled
   - Secure headers configured
   - SQL injection protection

2. **Static Files**
   - WhiteNoise for static file serving
   - Compressed and cached static files
   - Automatic static file collection

3. **Database**
   - SQLite for free tier (persistent)
   - PostgreSQL support available
   - Automatic migrations

4. **Performance**
   - Gunicorn WSGI server
   - Optimized static file serving
   - Database query optimization

### Troubleshooting Render Deployment

#### Common Issues

**1. Build Failures**
```bash
# Check build logs in Render dashboard
# Common causes:
# - Missing requirements.txt
# - Python version mismatch
# - Import errors
```

**2. Static Files Not Loading**
```bash
# Ensure build.sh includes:
python manage.py collectstatic --no-input

# Check STATIC_ROOT in settings.py
STATIC_ROOT = BASE_DIR / 'staticfiles'
```

**3. Database Issues**
```bash
# Ensure migrations run:
python manage.py migrate

# Check database permissions
# Verify database connection
```

**4. 500 Errors**
```bash
# Check Render logs
# Common causes:
# - Missing SECRET_KEY
# - Database connection issues
# - Import errors in views
```

#### Debug Commands

**Access Render Shell**
1. Go to your service in Render dashboard
2. Click "Shell" tab
3. Run debug commands:

```bash
# Check Django setup
python manage.py check

# Test database
python manage.py shell
>>> from claims.models import ClaimList
>>> ClaimList.objects.count()

# Check static files
python manage.py collectstatic --dry-run

# Test server locally
python manage.py runserver 0.0.0.0:8000
```

### Scaling on Render

#### Free Tier Limitations
- 750 hours/month
- 512MB RAM
- Shared CPU
- Sleep after 15 minutes of inactivity

#### Paid Plans
- **Starter**: $7/month - Always on, 512MB RAM
- **Standard**: $25/month - 1GB RAM, dedicated CPU
- **Pro**: $50/month - 2GB RAM, dedicated CPU

#### Upgrade Considerations
1. **Database**: Switch to PostgreSQL for better performance
2. **Static Files**: Use CDN for global distribution
3. **Caching**: Implement Redis for session storage
4. **Monitoring**: Add application monitoring

### Custom Domain Setup

1. **Add Custom Domain**
   - Go to your service in Render
   - Click "Settings" ‚Üí "Custom Domains"
   - Add your domain

2. **Update DNS**
   - Point your domain to Render's servers
   - Add CNAME record

3. **SSL Certificate**
   - Render provides automatic SSL
   - Certificates auto-renew

### Monitoring and Logs

#### Access Logs
1. Go to your service in Render
2. Click "Logs" tab
3. View real-time logs

#### Health Checks
- Render automatically checks `/` endpoint
- Configure custom health check path
- Monitor response times

#### Performance Monitoring
- Track request/response times
- Monitor memory usage
- Check database performance

### Backup and Recovery

#### Database Backup
```bash
# In Render shell
python manage.py dumpdata > backup.json

# Download backup
# Upload to secure storage
```

#### Code Backup
- Use Git for version control
- Regular commits to GitHub
- Tag releases for rollback

### Security Best Practices

1. **Environment Variables**
   - Never commit secrets to Git
   - Use Render's environment variables
   - Rotate secrets regularly

2. **Dependencies**
   - Keep dependencies updated
   - Monitor security advisories
   - Use virtual environments

3. **Access Control**
   - Use strong passwords
   - Implement rate limiting
   - Monitor access logs

### Cost Optimization

#### Free Tier Tips
- Use sleep mode for development
- Optimize static files
- Minimize database queries
- Use efficient caching

#### Paid Tier Optimization
- Right-size your service
- Use appropriate database plans
- Monitor resource usage
- Implement caching strategies

---

**Next Steps:**
1. Deploy to Render using the guide above
2. Set up your custom domain (optional)
3. Configure monitoring and alerts
4. Set up regular backups
5. Monitor performance and optimize

For additional help, check the [Render Documentation](https://render.com/docs) or contact Render support.
